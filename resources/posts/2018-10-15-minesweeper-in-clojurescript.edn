{:title "Minesweeper with clojurescript"
 :description ""
 :link (fn [k]
         (let [links {:coding-challange ["https://www.youtube.com/playlist?list=PLRqwX-V7Uu6ZiZxtDDRCi6uhfTH4FilpH" "The Coding Train Coding Challenges"]
                      :p5 ["https://p5js.org/" "p5.js"]
                      :daniel ["https://twitter.com/shiffman" "Daniel Shiffman"]
                      :minesweeper ["https://www.youtube.com/watch?v=LFU5ZlrR21E" "minesweeper coding challange"]
                      :mine-wiki ["https://en.wikipedia.org/wiki/Minesweeper_(video_game)" "minesweeper"]
                      :minesweeper-game [(sneakycode.config/url "/minesweeper") "play the full version here"]
                      :clojure ["https://clojurescript.org/" "Clojure/Clojurescript"]}
               [url text] (get links k)]
           [:a {:href url :target "_blank"} text]))
 :content
 (fn [{:keys [slug link]}]
   [:div.content
    [:p "I have been working my way through the "
     (link :coding-challange)
     " videos on youtube. So far they have been quite informative and entertaining.
There is something about combining math and graphics that has grabbed my attention and I have started to play around with building drawings and games using "
     (link :p5)
     " and clojurescript. "
     (link :daniel)
     " does an excellent job in presenting and producing these videos and I suggest you go and check them out."]
    [:p "Daniel typically does these challanges in a javascript object oriented style. I have been keen for a while to replicate these challanges using Functional Programming (via " (link :clojure) ") and this is the first attempt. In doing this I hope to 1. have fun and 2. get people excited about Clojure.
Clojure has turned everything I believed about software on it's head and I am a better developer because of it. I am also having lots of fun."]
    [:p "I'll be building a " (link :mine-wiki)" clone. You should go and watch the " (link :minesweeper) " as this will give you a nice idea of how the OO and FP paridimes differ. "
     "Below is a tiny demo of the game (shift click to flag) and you can go and " (link :minesweeper-game) "."]

    [:div {:id "game" :style "display: inline-flex; box-shadow: 10px 14px 19px -9px rgba(0,0,0,0.15);"}]

    [:hr]
    [:h4 "Let's build!"]
    [:p "Clojure is a dynamic functional hosted lisp. The lisp syntax might be trippy if you come from curly bracket land, but in essence it is always"
     [:code "(my-function arg1 arg2 ...)"]
     " ... for everything ... ever. Clojure is functional and its core datastructures are persistant so we will be focusing on building the core minesweeper functionality using pure functions that opperate on immutable data. Once this is done we will add a state handling mechanism and finally the drawing of the game on the screen. This is typically how we build functional applications. We have a stateful outer layer that calls into a functional inner layer. Like a metaphorical functional sandwitch. Yummy!" ]
    [:p "Before I start writing any code I first want to talk about what I want my data to look like. Minesweeper is essencially just rows and columns of cells. Although I can identify each cell by its row and column, I would prefer to give each cell an index and have my entire board represented as a map of indexes to cells. This allows me todo easy value lookups and update. Because the the basic board state does not change during the game, I can initialize the cells with all the information about their neighbouring cells so I can avoid having to iterate the cells when I need to check bomb locations etc. My core grid datastructure then ends up looking like this:"]
    (sneakycode.render/clj
     {:map {:sort? false}}
     {0 {:i 0 :row 0 :col 0
         :type :empty
         :flagged? false
         :opened? false
         :neighbours [1 5 6]
         :bombs-touching 0
         }
      1 {:i 1 :row 0 :col 1 :type ..}
      2 {:i 2 :row 0 :col 2 :type ..}})

    [:p "Now that I have an idea of what the data is going to look like, I can start creating and combining functions to build up the board state. The first thing I want to be able todo is to convert an index to a row and column and vice versa."]
    (sneakycode.render/clj
     {}
     (defn position
       "given the grid width and index, returns a vector containing column and row"
       [col-count i]
       (let [col (mod i col-count)
             row (/ (- i col) col-count)]
         [col row]))

     (defn index
       "given the grid width and the row and column, returns the index"
       [col-count row col]
       (+ col (* row col-count))))
    [:p "With that out of the way we can write a simple function that, given a grid width and an index, will create an empty cell."]
    (sneakycode.render/clj
     {:map {:sort? false :force-nl? true}}
     (defn cell [col-count i]
       (let [[col row] (position col-count i)]
         {:i        i :row row :col col
          :type     :empty
          :flagged? false
          :opened?  false})))

    [:h5 "Creating the board"]
    (sneakycode.render/markdown
     "At the start of each game we want to initialize a new board. This is done in three simple steps.

1. Initialize the board with empty cells.
2. Randomly place some bombs.
3. Calculate the number of bombs each cell is touching.

**Initializing** the grid is fairly simple. We simply calculate the number of cells, create a list of indexes from 0 to size-1 using `range`, map over this list and create an empty cell for each index and finally, using `juxt` and `into`, create the map strucute we defined above. The threading macro (`->>`) helps us keep the code nice and readable.
" )
    (sneakycode.render/clj
     {:parse-string? true}
     "(defn init-cells [row-count col-count]
       (let [size (* row-count col-count)]
         (->> (range size) ; => (0 1 2 ... size-1)
              (map #(cell col-count %)) ; => ({:i 0 :row ..} {:i 1 :row ..} ...)
              (map (juxt :i identity))
              (into {}) ; => {0 {:i 0 :row ..} 1 {:i 1 :row ..} ...}
)))")

    (sneakycode.render/markdown
     "To **randomly place bombs** on the existing grid, we will create a loop that counts down from the number of bombs to zero. For every iteration we will randomly pick one of the empty cells and set its type to `:bomb`. That cell gets removed from the set of empty cells and we go back to the start of the loop until all bombs are placed. Recursion is the functional/immutable worlds answer to for loops that update state as part of their body. We use recur for non-stack-consuming looping.")
    (sneakycode.render/clj
     {:parse-string? true}
     "(defn place-bombs [bomb-count cells-map]
       (loop [bomb-count  bomb-count
              empty-cells (set (keys cells-map))
              result      cells-map]
         (if (<= bomb-count 0)
           result
           (let [random-index (rand-int (count empty-cells))
                 bomb-index   (nth (vec empty-cells) random-index)]
             (recur
              (dec bomb-count) ; bomb-count - 1
              (disj empty-cells bomb-index) ; remove index from empty cells
              (assoc-in result [bomb-index :type] :bomb) ; update cell at index
)))))")

    (sneakycode.render/markdown
     "For each cell, we want to know how many of their adjacent cells contains bombs. We will do this using two functions. The first function `neighbours` is a helper function that, given a cell, returns all the indexes of that cells neighbours. The `set-neighbours` function will map over our cells and for each cell set its neighbours, count its adjacent bomb cells and change the type of the cell if it is bomb adjacent.")
    (sneakycode.render/clj
     {:parse-string? true}
     "
     (defn neighbours
       \"Calculates the indexes of a cell' neighbours\"
       [row-count col-count cell]
       (let [{:keys [i row col]} cell
             row-                (dec row)
             row+                (inc row)
             col-                (dec col)
             col+                (inc col)
             neighbours          [[col- row-] [col row-] [col+ row-]
                                  [col- row]             [col+ row]
                                  [col- row+] [col row+] [col+ row+]]]
         (->> neighbours
              (filter (fn [[col row]] ; remove out of bounds cells
                        (and (>= row 0) (>= col 0)
                             (< row row-count) (< col col-count))))
              (map (fn [[col row]] ; get the neighbour cell index
                     (index col-count row col))))))"

     )
    (sneakycode.render/clj
     {:parse-string? true}
     "(defn set-neighbours
       \"Calculates bomb adjacent cell totals and updates cell types if bomb adjacent\"
       [row-count col-count cells-map]
       (->> cells-map
            (map (fn [[i cell]]
                   (let [neighbours     (neighbours row-count col-count cell)
                         bombs-touching (->> neighbours ; count adjacent bombs
                                             (filter #(= :bomb (get-in cells-map [% :type])))
                                             count)]
                     [i
                      (assoc cell
                             :neighbours neighbours
                             :bombs-touching bombs-touching
                             :type (cond
                                     (= :bomb (:type cell)) :bomb
                                     (> bombs-touching 0)   :bomb-adjacent
                                     :else                  (:type cell)))])))
            (into {})))")
    (sneakycode.render/markdown
     "Finally we can compose our above functions into a single, board generating, function.")
    (sneakycode.render/clj
     {}
     (defn board [row-count col-count bomb-count]
       (->> (init-cells row-count col-count)
            (place-bombs bomb-count)
            (set-neighbours row-count col-count))))

    [:h5 "Handling game actions"]
    (sneakycode.render/markdown
     "Now that we have a board we want to be change the board state in a number of ways. We want to be able to:

* toggle a cell as flagged
* open a cell, which in turn will either
    * detonate a bomb, causing us to lose the game
    * open a cell that is bomb adjacent
    * open an empty cell and recursively open all other non bomb cells that are adjacent
* Check if we won the game

Let's start with the latter. We have won the game if there are only bomb cells left to be opened")

    (sneakycode.render/clj
     {}
     (defn win? [board]
       (->> board
            vals
            (filter not-opened-non-bomb-cell?)
            empty?)))
    [:div [:p "Toggeling a cell as flagged is pretty straight forward. We simply set flagged as true:"]]
    (sneakycode.render/clj
     {}
     (defn toggle-cell-flag [board i]
       (update-in board [i :flagged?] not)))
    [:div [:p "Opening an adjacent cell is also easy mode"]]
    (sneakycode.render/clj
     {}
     (defn open-adjacent-cell [board i]
       (assoc-in board [i :opened?] true)))
    [:div [:p "As is detonating a bomb. Detonating a bomb opens all cells to reveal the entire board"]]
    (sneakycode.render/clj
     {}
     (defn detonate [board {:keys [i] :as cell}]
       (->> board
            (map (fn [[i cell]]
                   [i (assoc cell :opened? true)]))
            (into {}))))
    ;;;; Load minesweeper
    (sneakycode.render/snippet :p5)
    (sneakycode.render/snippet :cljs "minesweeper")
    [:script "window.addEventListener('load', mine.core.phone_game)"]
    ])}
