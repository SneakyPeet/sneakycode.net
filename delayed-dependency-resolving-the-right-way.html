<!DOCTYPE html>

<html></html><html class="has-navbar-fixed-top"><head><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-58216004-1"></script><script>window.dataLayer = window.dataLayer || [];
                 function gtag(){dataLayer.push(arguments);}
                 gtag('js', new Date());
                 gtag('config', 'UA-58216004-1');</script><meta charset="utf-8" content="text/html" /><meta content="width=device-width, initial-scale=1" name="viewport" /><link href="https://sneakycode.net/delayed-dependency-resolving-the-right-way" rel="canonnical" /><link href="https://sneakycode.net/rss/" rel="alternative" title="SneakyCode" type="application/rss+xml" /><title>Delayed Dependency Resolution the Right Way</title><meta content="I have been playing around with CQRS/Event Sourcing and using lightweight, immutable command messages to trigger actions in my application. The great thing about this is that you can specify a single point of entry into your application by using a very simple interface." name="description" /><meta content="Pieter Koornhof" name="author" /><link href="https://sneakycode.net/apple-icon-57x57.png" rel="apple-touch-icon" sizes="57x57" /><link href="https://sneakycode.net/apple-icon-60x60.png" rel="apple-touch-icon" sizes="60x60" /><link href="https://sneakycode.net/apple-icon-72x72.png" rel="apple-touch-icon" sizes="72x72" /><link href="https://sneakycode.net/apple-icon-76x76.png" rel="apple-touch-icon" sizes="76x76" /><link href="https://sneakycode.net/apple-icon-114x114.png" rel="apple-touch-icon" sizes="114x114" /><link href="https://sneakycode.net/apple-icon-120x120.png" rel="apple-touch-icon" sizes="120x120" /><link href="https://sneakycode.net/apple-icon-144x144.png" rel="apple-touch-icon" sizes="144x144" /><link href="https://sneakycode.net/apple-icon-152x152.png" rel="apple-touch-icon" sizes="152x152" /><link href="https://sneakycode.net/apple-icon-180x180.png" rel="apple-touch-icon" sizes="180x180" /><link href="https://sneakycode.net/android-icon-192x192.png" rel="icon" sizes="192x192" type="image/png" /><link href="https://sneakycode.net/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png" /><link href="https://sneakycode.net/favicon-96x96.png" rel="icon" sizes="96x96" type="image/png" /><link href="https://sneakycode.net/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png" /><link href="https://sneakycode.net/manifest.json" rel="manifest" /><meta content="#ffffff" name="msapplication-TileColor" /><meta content="ms-icon-144x144.png" name="msapplication-TileImage" /><meta content="#ffffff" name="theme-color" /><meta content="SneakyCode" property="og:site_name" /><meta content="article" property="og:type" /><meta content="Delayed Dependency Resolution the Right Way" property="og:title" /><meta content="I have been playing around with CQRS/Event Sourcing and using lightweight, immutable command messages to trigger actions in my application. The great thing about this is that you can specify a single point of entry into your application by using a very simple interface." property="og:description" /><meta content="https://sneakycode.net/delayed-dependency-resolving-the-right-way" property="og:url" /><meta content="clean code" property="article:tag" /><meta content="dependency injection" property="article:tag" /><meta content="ioc" property="article:tag" /><meta content="castle windsor" property="article:tag" /><link href="https://sneakycode.net/style.css" rel="stylesheet" /><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" /></head><body><nav class="navbar is-fixed-top is-dark has-gradient" role="navigation"><div class="navbar-brand"><a class="navbar-item has-text-weight-bold" href="https://sneakycode.net/">sneakycode</a></div></nav><nav aria-label="main navigation" class="navbar is-fixed-bottom is-dark has-gradient" role="navigation"><div class="navbar-brand"><a aria-label="home" class="navbar-item" href="https://sneakycode.net/"><span class="icon"><i class="fa fa-lg fa-bath"></i></span></a><a aria-label="history" class="navbar-item" href="https://sneakycode.net/all-posts"><span class="icon"><i class="fa fa-lg fa-history"></i></span></a><a aria-label="tags" class="navbar-item" href="https://sneakycode.net/tags"><span class="icon"><i class="fa fa-lg fa-tags"></i></span></a><a aria-label="rss" class="navbar-item" href="https://sneakycode.net/rss.rss"><span class="icon"><i class="fa fa-lg fa-rss"></i></span></a><a aria-label="github" class="navbar-item" href="https://github.com/sneakypeet" target="_blank"><span class="icon"><i class="fa fa-lg fa-github"></i></span></a><a aria-label="twitter " class="navbar-item" href="https://twitter.com/PieterKoornhof" target="_blank"><span class="icon"><i class="fa fa-lg fa-twitter"></i></span></a></div></nav><div class="section"><div class="container"><div class="columns is-8 is-variable is-desktop"><article class="column is-three-quarters-desktop"><h1 class="title has-text-weight-light">Delayed Dependency Resolution the Right Way</h1><p class="subtitle is-6 post-tags"><span class="tags"><span class="tag is-primary tag-lite">2016-03-01</span><a class="tag" href="https://sneakycode.net/tag/castle-windsor">castle windsor</a><a class="tag" href="https://sneakycode.net/tag/clean-code">clean code</a><a class="tag" href="https://sneakycode.net/tag/dependency-injection">dependency injection</a><a class="tag" href="https://sneakycode.net/tag/ioc">ioc</a></span></p><div class="has-text-justified content"><p>I have been playing around with CQRS/Event Sourcing and using lightweight, immutable command messages to trigger actions in my application. The great thing about this is that you can specify a single point of entry into your application by using a very simple interface.</p>
<pre class="syntax"><code class="csharp"><span></span><span class="k">public</span> <span class="k">interface</span> <span class="n">IApplication</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="n">Execute</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">command</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">ICommand</span><span class="p">;</span>
<span class="p">}</span>
</code></pre><p>This means that every time you want to expose a new actionable feature, you just provide the client with a simple command object.</p>
<pre class="syntax"><code class="fsharp"><span></span><span class="c1">// this is F#</span>
<span class="k">type</span> <span class="nc">HireEmployee</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">EmployeeId</span><span class="o">:</span> <span class="n">Guid</span><span class="o">;</span>
  <span class="n">Name</span><span class="o">:</span> <span class="n">String</span><span class="o">;</span>
  <span class="n">HireDate</span><span class="o">:</span> <span class="n">DateTime</span><span class="o">;</span>
<span class="o">}</span> <span class="k">with</span> <span class="k">interface</span> <span class="n">ICommand</span>
</code></pre><p>(By the way I like implementing my command and event messages in f# because f# has structural equality and immutability by default which means I do not have to write constructor boilerplate and override equality methods.)</p><p>No more creating a bunch of Application Interfaces that your client needs to consume. You just add the appropriate command handler implementation inside of your application.</p>
<pre class="syntax"><code class="csharp"><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">HireEmployeeHandler</span> <span class="p">:</span> <span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">HireEmployee</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Handle</span><span class="p">(</span><span class="n">HireEmployee</span> <span class="n">command</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>
</code></pre><p><strong>There is however a tiny issue with IoC container wireup</strong>. Typically we are used to calling resolve on our container once at the entry point of our system. Our container will then inject all our dependencies and bob's your uncle! However can you spot the problem with our above example? By the time we need to figure out what CommandHandler to use, we have already resolved our dependencies. This means that we need to explicitly resolve the dependencies for our CommandHandler again.</p><p>Simple you say! I'll just pass my container into the code that resolves my command handler.</p>
<pre class="syntax"><code class="csharp"><span></span><span class="k">class</span> <span class="nc">CommandDispatcher</span> <span class="p">:</span> <span class="n">ICommandDispatcher</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IContainer</span> <span class="n">container</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">CommandDispatcher</span><span class="p">(</span><span class="n">IContainer</span> <span class="n">container</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">container</span> <span class="p">=</span> <span class="n">container</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="n">Send</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">command</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">ICommand</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">handler</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>
        <span class="n">handler</span><span class="p">.</span><span class="n">Handle</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre><p><strong>DO NOT DO THIS!</strong></p><p>The clean code god's will smite you for introducing the concept of a container into your domain and doing service location. Your IoC container should sit on the outermost layer of your application and assist you in building up complex dependencies. Other than container wire up you should only be calling <code>container.Resolve()</code> in once place. If your application is small you can ask yourself <em>"do I even need an IoC container?"</em>. Remember that not having an IoC container does not mean that you are not doing Dependency Injection. Because your IoC does magic to make your life easy, it does not mean you should abuse it by building up huge dependency trees that go 10 levels deep and injecting to many dependencies.</p><p><code>#rant</code> Let's get back to solving the problem. A better solution would be to do something like this.</p>
<pre class="syntax"><code class="csharp"><span></span><span class="k">class</span> <span class="nc">CommandDispatcher</span> <span class="p">:</span> <span class="n">ICommandDispatcher</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ICommandHandlerFactory</span> <span class="n">factory</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">CommandDispatcher</span><span class="p">(</span><span class="n">ICommandHandlerFactory</span> <span class="n">factory</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">factory</span> <span class="p">=</span> <span class="n">factory</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="n">Send</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">command</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">ICommand</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">handler</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
        <span class="n">handler</span><span class="p">.</span><span class="n">Handle</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">Destroy</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span> <span class="c1">//you have to explicitly manage the life cycle of your handler</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="n">ICommandHandlerFactory</span>
<span class="p">{</span>
    <span class="n">ICommandHandler</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Create</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">T</span> <span class="n">command</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">ICommand</span><span class="p">;</span>
    <span class="k">void</span> <span class="nf">Destroy</span><span class="p">(</span><span class="kt">object</span> <span class="n">handler</span><span class="p">);</span>
<span class="p">}</span>
</code></pre><p>How is this different? First of all you are expressing your needs without polluting your domain. If you ever decide to chuck out your IoC container for a different one, your domain would be unaffected. You would not have to change a single line of code in your domain. The only thing that you would have to do is as part of your container wireup you would need to actually implement <code>ICommandHandlerFactory</code>. Because you are doing DI, the implementation does not have to sit inside your domain, but can live outside of it alongside your container.</p><p>If you are using <a href="https://github.com/castleproject/Windsor">Castle Windsor</a> you are in luck. They provide a <a href="https://github.com/castleproject/Windsor/blob/master/docs/typed-factory-facility.md">Typed Factory Facility</a> which means you do not even have to implement <code>ICommandHandlerFactory</code>! You just need initialize the factory in you container wireup and bob is your uncle again!</p>
<pre class="syntax"><code class="csharp"><span></span><span class="n">container</span><span class="p">.</span><span class="n">AddFacility</span><span class="p">&lt;</span><span class="n">TypedFactoryFacility</span><span class="p">&gt;();</span>

<span class="n">container</span><span class="p">.</span><span class="n">Register</span><span class="p">(</span>
    <span class="n">Component</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="n">ICommandHandlerFactory</span><span class="p">&gt;()</span>
             <span class="p">.</span><span class="n">AsFactory</span><span class="p">()</span>
<span class="p">);</span>
</code></pre><p><strong>Nifty!</strong> Remember kids, Inject Responsibly!</p><p><a href="http://www.codeproject.com/script/Articles/BlogFeedList.aspx?amid=8804440" rel="tag" style="display:none">CodeProject</a></p></div></article><div aria-label="pagination" class="column" role="navigation"><div class="short-timeline"><div class="timeline is-rtl"><div class="timeline-header"><a class="tag is-primary tag-lite" href="https://sneakycode.net/better-test-documentation">Older</a></div><div class="timeline-item"><div class="timeline-marker"></div><div class="timeline-content"><a class="header" href="https://sneakycode.net/better-test-documentation">Better Test Documentation</a></div></div><div class="timeline-header"><a class="tag is-primary tag-lite" href="https://sneakycode.net/event-sourcing-and-battling-accidental-complexity-devday2016">Newer</a></div><div class="timeline-item"><div class="timeline-marker"></div><div class="timeline-content"><a class="header" href="https://sneakycode.net/event-sourcing-and-battling-accidental-complexity-devday2016">Event Sourcing and Battling Accidental Complexity (DevDay2016)</a></div></div><div class="timeline-header"><span class="tag is-primary tag-lite">end</span></div></div></div></div></div><div><div id="disqus_thread"></div><script>var disqus_config = function () {
           this.page.url = 'http://sneakycode.net/delayed-dependency-resolving-the-right-way';
           // this.page.identifier = PAGE_IDENTIFIER;
         };
         (function() { // DON'T EDIT BELOW THIS LINE
           var d = document, s = d.createElement('script');
           s.src = 'https://sneakycode.disqus.com/embed.js';
           s.setAttribute('data-timestamp', +new Date());
           (d.head || d.body).appendChild(s);
         })();</script></div></div></div></body></html>